/*
 * SSH State Learner - A tool for extracting state machines from SSH server implementations
 *
 * Copyright 2021 Ruhr University Bochum, Paderborn University, Hackmanit GmbH
 *
 * Licensed under Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 */
package de.rub.nds.sshstatelearner.algorithms

import de.learnlib.sul.SUL
import de.learnlib.oracle.EquivalenceOracle
import de.learnlib.oracle.MembershipOracle
import de.learnlib.filter.cache.LearningCache
import de.learnlib.oracle.equivalence.CompleteExplorationEQOracle
import de.learnlib.oracle.equivalence.EQOracleChain
import de.learnlib.oracle.equivalence.RandomWMethodEQOracle
import de.learnlib.oracle.equivalence.RandomWordsEQOracle
import de.learnlib.oracle.equivalence.RandomWpMethodEQOracle
import de.learnlib.oracle.equivalence.WMethodEQOracle
import de.learnlib.oracle.equivalence.WpMethodEQOracle
import de.learnlib.oracle.equivalence.mealy.RandomWalkEQOracle
import de.rub.nds.sshattacker.core.constants.KeyExchangeAlgorithm
import de.rub.nds.sshstatelearner.constants.EquivalenceOracleType
import de.rub.nds.sshstatelearner.exceptions.IllegalKeyExchangeException
import de.rub.nds.sshstatelearner.extraction.SshSymbol
import de.rub.nds.sshstatelearner.constants.ProtocolStage
import de.rub.nds.sshstatelearner.constants.SulType
import de.rub.nds.sshstatelearner.sul.response.ResponseFingerprint
import net.automatalib.automaton.transducer.MealyMachine
import net.automatalib.word.Word
import java.util.*

/**
 * This object is capable of creating equivalence oracle instances to use within an active automaton learning
 * setup. It allows default values to be set via the according setter functions for each equivalence algorithm.
 */
object EquivalenceOracleFactory {

    /**
     * The default protocol stage used to determine the correct happy flow to use.
     */
    var happyFlowProtocolStage: ProtocolStage = ProtocolStage.CONNECTION
        private set

    /**
     * The default key exchange algorithm used to determine the correct happy flow to use.
     */
    var happyFlowKex: KeyExchangeAlgorithm = KeyExchangeAlgorithm.DIFFIE_HELLMAN_GROUP_EXCHANGE_SHA256
        private set

    /**
     * The maximum number of symbol insertions to check equivalence for in a happy flow equivalence oracle.
     */
    var happyFlowMaximumInsertions: Int = 2
        private set

    /**
     * An alternative alphabet to use for the happy flow equivalence oracle. If empty, the default alphabet is used.
     */
    var happyFlow: Word<SshSymbol>? = null

    /**
     * Minimum exploration depth for complete exploration oracles. The oracle effectively generates all words with
     * length between completeExplorationMinDepth and completeExplorationMaxDepth.
     */
    var completeExplorationMinDepth: Int = 3
        private set

    /**
     * Maximum exploration depth for complete exploration oracles. The oracle effectively generates all words with
     * length between completeExplorationMinDepth and completeExplorationMaxDepth.
     */
    var completeExplorationMaxDepth: Int = 6
        private set

    /**
     * The minimum length of a single word to be generated by a random word equivalence oracle.
     */
    var randomWordsMinLength: Int = 5
        private set

    /**
     * The maximum length of a single word to be generated by a random word equivalence oracle.
     */
    var randomWordsMaxLength: Int = 15
        private set

    /**
     * The number of words to be generated by a random word equivalence oracle.
     */
    var randomWordsMaxTests: Int = 1000
        private set

    /**
     * The probability that the walk performed by a random walk equivalence oracle is restarted
     * (i.e. a new word begins) after each step.
     */
    var randomWalkRestartProbability: Double = 0.1
        private set

    /**
     * The maximum amount of steps to walk by a random walk equivalence oracle before the hypothesis and SUL are
     * considered equal.
     */
    var randomWalkMaxSteps: Long = 10000
        private set

    /**
     * The maximum length of the "middle" part of all words generated by a W(p)-method equivalence oracle.
     */
    var wLookahead: Int = 2
        private set

    /**
     * The expected size of the system under learning.
     */
    var wExpectedSize: Int = 10
        private set

    /**
     * The minimal size of a random word generated by a random W(p)-method equivalence oracle.
     */
    var randomWMinimalSize: Int = 3
        private set

    /**
     * The expected length of a random word generated by a random W(p)-method equivalence oracle. The effective expected
     * length is equal to randomWMethodMinimalSize + randomWMethodRndLength.
     */
    var randomWRndLength: Int = 7
        private set

    /**
     * The maximum number of words to generate by a random W(p)-method equivalence oracle. If set to 0 (unbounded),
     * a call to findCounterExample does not terminate if the hypothesis is correct.
     */
    var randomWBound: Int = 1000
        private set

    /**
     * Sets the factory defaults for a happy flow equivalence oracle.
     *
     * @param maximumInsertions The maximum number of message insertions to check equivalence for.
     */
    fun setHappyFlowDefaults(
        stage: ProtocolStage,
        kex: KeyExchangeAlgorithm,
        maximumInsertions: Int,
        happyFlow: Word<SshSymbol>? = null
    ) {
        if (maximumInsertions < 0) {
            throw IllegalArgumentException("Unable to set default values for a happy flow equivalence oracle. The maximum number of insertions (value: $maximumInsertions) is negative.")
        }
        if (kex.flowType == null) {
            throw IllegalKeyExchangeException("Unable to set default values for a happy flow equivalence oracle. ext-info-s and ext-info-c are no valid kex algorithms.")
        }
        happyFlowProtocolStage = stage
        happyFlowKex = kex
        happyFlowMaximumInsertions = maximumInsertions
        this.happyFlow = happyFlow
    }

    /**
     * Sets the factory defaults for a complete exploration, depth-bounded equivalence oracle.
     *
     * @param minDepth Minimum exploration depth (i.e. minimum length of words to be tested).
     * @param maxDepth Maximum exploration depth (i.e. maximum length of words to be tested).
     */
    fun setCompleteExplorationDefaults(minDepth: Int, maxDepth: Int) {
        if (minDepth < 0 || maxDepth < 0) {
            throw IllegalArgumentException("Unable to set default values for a complete exploration equivalence oracle. Either the minimum depth (value: $minDepth) or maximum depth (value: $maxDepth) is negative.")
        }
        if (maxDepth < minDepth) {
            throw IllegalArgumentException("Unable to set default values for a complete exploration equivalence oracle. The maximum depth (value: $maxDepth) must always be greater or equal than the minimum depth (value: $minDepth).")
        }
        completeExplorationMinDepth = minDepth
        completeExplorationMaxDepth = maxDepth
    }

    /**
     * Sets the factory defaults for a random words equivalence oracle.
     *
     * @param minLength Minimum length of words to be tested.
     * @param maxLength Maximum length of words to be tested.
     * @param maxTests Maximum number of tests to perform before hypothesis and SUL are considered equal.
     */
    fun setRandomWordsDefaults(minLength: Int, maxLength: Int, maxTests: Int) {
        if (minLength < 0 || maxLength < 0) {
            throw IllegalArgumentException("Unable to set default values for a random words equivalence oracle. Either the minimal length (value: $minLength) or maximal length (value: $maxLength) is negative.")
        }
        if (maxTests <= 0) {
            throw IllegalArgumentException("Unable to set default values for a random words equivalence oracle. The maximum number of tests (value: $maxTests) is less or equal 0.")
        }
        if (maxLength < minLength) {
            throw IllegalArgumentException("Unable to set default values for a random words equivalence oracle. The maximum length (value: $maxLength) must always be greater or equal to minLength ($minLength).")
        }
        randomWordsMinLength = minLength
        randomWordsMaxLength = maxLength
        randomWordsMaxTests = maxTests
    }

    /**
     * Sets the factory defaults for a random walk equivalence oracle.
     *
     * @param restartProbability The probability that the walk performed by a random walk equivalence oracle is restarted (i.e. a new word begins) after each step.
     * @param maxSteps Maximum number of steps to walk before hypothesis and SUL are considered equal.
     */
    fun setRandomWalkDefaults(restartProbability: Double, maxSteps: Long) {
        if (restartProbability < 0 || restartProbability > 1) {
            throw IllegalArgumentException("Unable to set default values for a random walk equivalence oracle. The restart probability (value: $restartProbability) is not within the range [0, 1].")
        }
        if (maxSteps <= 0) {
            throw IllegalArgumentException("Unable to set default values for a random walk equivalence oracle. The maximum number of steps to walk (value: $maxSteps) is less or equal 0.")
        }
        randomWalkRestartProbability = restartProbability
        randomWalkMaxSteps = maxSteps
    }

    /**
     * Sets the factory defaults for a W-method and Wp-method equivalence oracle.
     *
     * @param lookahead The maximum length of the "middle" part of all words generated.
     * @param expectedSize The expected size of the system under learning.
     */
    fun setWDefaults(lookahead: Int, expectedSize: Int) {
        if (lookahead < 0) {
            throw IllegalArgumentException("Unable to set default values for a W(p)-method equivalence oracle. The lookahead (value: $lookahead) is negative.")
        }
        if (expectedSize < 0) {
            throw IllegalArgumentException("Unable to set default values for a W(p)-method equivalence oracle. The expected size (value: $expectedSize) is negative.")
        }
        wLookahead = lookahead
        wExpectedSize = expectedSize
    }

    /**
     * Sets the factory defaults for a random W-method and Wp-method equivalence oracle.
     *
     * @param minimalSize The minimal size of a random word.
     * @param rndLength The expected length of a random word. The effective expected length is minimalSize + rndLength.
     * @param bound The maximum number of words to test before hypothesis and SUL are considered equal. If this oracle is configured to be unbounded (bound = 0), it does not terminate if the hypothesis is correct.
     */
    fun setRandomWDefaults(minimalSize: Int, rndLength: Int, bound: Int) {
        if (minimalSize < 0 || rndLength < 0) {
            throw IllegalArgumentException("Unable to set default values for a random W(p)-method equivalence oracle. The minimal size (value: $minimalSize) or random length (value: $rndLength).")
        }
        if (bound < 0) {
            throw IllegalArgumentException("Unable to set default values for a random W(p)-method equivalence oracle. The maximum number of words to generate (value: $bound) is negative.")
        }
        randomWMinimalSize = minimalSize
        randomWRndLength = rndLength
        randomWBound = bound
    }

    /**
     * Creates a new instance of the specified equivalence oracle type using the provided membership oracle / SUL /
     * learning cache and the factory defaults set prior to the create() call.
     *
     * @param type The type of the equivalence oracle to create.
     * @param membershipOracle A membership oracle of the system to learn. Required if type is unequal RANDOM_WALK and CACHE_CONSISTENCY.
     * @param sul The SUL. Only required if type is RANDOM_WALK.
     * @param learningCache The learning cache. Only required if type is CACHE_CONSISTENCY
     * @return An instance of the equivalence oracle specified by type and the predefined defaults.
     */
    fun create(
        type: EquivalenceOracleType,
        membershipOracle: MembershipOracle<SshSymbol, Word<ResponseFingerprint>>,
        sul: SUL<SshSymbol, ResponseFingerprint>,
        sulType: SulType,
        learningCache: LearningCache<MealyMachine<*, SshSymbol, *, ResponseFingerprint>, SshSymbol, Word<ResponseFingerprint>>,
        batchSize: Int
    ): EquivalenceOracle<MealyMachine<*, SshSymbol, *, ResponseFingerprint>, SshSymbol, Word<ResponseFingerprint>> {
        // TODO: Implement custom RANDOM_WALK that supports a membership oracle
        return when (type) {

            EquivalenceOracleType.CACHE_CONSISTENCY -> learningCache.createCacheConsistencyTest()
                ?: throw IllegalArgumentException("Unable to create CACHE_CONSISTENCY equivalence oracle without a learning cache")

            EquivalenceOracleType.HAPPY_FLOW -> HappyFlowEQOracle(
                membershipOracle,
                happyFlowProtocolStage,
                happyFlowKex,
                happyFlowMaximumInsertions,
                sulType,
                batchSize,
                happyFlow
            )

            EquivalenceOracleType.COMPLETE_EXPLORATION -> CompleteExplorationEQOracle(
                membershipOracle,
                completeExplorationMinDepth,
                completeExplorationMaxDepth,
                batchSize
            )

            EquivalenceOracleType.RANDOM_WORDS -> RandomWordsEQOracle(
                membershipOracle,
                randomWordsMinLength,
                randomWordsMaxLength,
                randomWordsMaxTests,
                Random(Date().time),
                batchSize
            )

            EquivalenceOracleType.RANDOM_WALK -> RandomWalkEQOracle(
                sul,
                randomWalkRestartProbability,
                randomWalkMaxSteps,
                Random(Date().time)
            )

            EquivalenceOracleType.W -> WMethodEQOracle(
                membershipOracle,
                wLookahead,
                wExpectedSize,
                batchSize)

            EquivalenceOracleType.RANDOM_W -> RandomWMethodEQOracle(
                membershipOracle,
                randomWMinimalSize,
                randomWRndLength,
                randomWBound,
                batchSize
            )

            EquivalenceOracleType.WP -> WpMethodEQOracle(
                membershipOracle,
                wLookahead,
                wExpectedSize,
                batchSize)

            EquivalenceOracleType.RANDOM_WP -> RandomWpMethodEQOracle(
                membershipOracle,
                randomWMinimalSize,
                randomWRndLength,
                randomWBound,
                batchSize
            )
        }
    }

    /**
     * Creates a new equivalence oracle chain using the specified types. Each oracle is instantiated by calling the
     * create method.
     *
     * @param types The list of oracle types to create and chain.
     * @param membershipOracle A membership oracle of the system to learn. Required if types contains a type that is unequal RANDOM_WALK and CACHE_CONSISTENCY.
     * @param sul The SUL. Only required if types contains RANDOM_WALK.
     * @param learningCache The learning cache. Only required if types contains CACHE_CONSISTENCY.
     * @return A chain of multiple equivalence oracles specified by types and the predefined defaults.
     */
    fun createChain(
        types: Iterable<EquivalenceOracleType>,
        membershipOracle: MembershipOracle<SshSymbol, Word<ResponseFingerprint>>,
        sul: SUL<SshSymbol, ResponseFingerprint>,
        sulType: SulType,
        learningCache: LearningCache<MealyMachine<*, SshSymbol, *, ResponseFingerprint>, SshSymbol, Word<ResponseFingerprint>>,
        batchSize: Int
    ): EquivalenceOracle<MealyMachine<*, SshSymbol, *, ResponseFingerprint>, SshSymbol, Word<ResponseFingerprint>> {
        return EQOracleChain(types.map {
            create(
                it,
                membershipOracle,
                sul,
                sulType,
                learningCache,
                batchSize
            )
        })
    }
}
